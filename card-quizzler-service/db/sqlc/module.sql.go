// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: module.sql

package card_quizzler_service

import (
	"context"
)

const createModule = `-- name: CreateModule :exec
INSERT INTO modules (id, title, user_id) VALUES ($1, $2, $3)
`

type CreateModuleParams struct {
	ID     string
	Title  string
	UserID string
}

func (q *Queries) CreateModule(ctx context.Context, arg CreateModuleParams) error {
	_, err := q.db.Exec(ctx, createModule, arg.ID, arg.Title, arg.UserID)
	return err
}

const deleteModule = `-- name: DeleteModule :exec
DELETE FROM modules WHERE id = $1
`

func (q *Queries) DeleteModule(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteModule, id)
	return err
}

const getAllModulesByUserID = `-- name: GetAllModulesByUserID :many
SELECT
       m.id AS module_id,
       m.title AS module_title
FROM modules m
WHERE m.user_id = $1
`

type GetAllModulesByUserIDRow struct {
	ModuleID    string
	ModuleTitle string
}

func (q *Queries) GetAllModulesByUserID(ctx context.Context, userID string) ([]GetAllModulesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getAllModulesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllModulesByUserIDRow
	for rows.Next() {
		var i GetAllModulesByUserIDRow
		if err := rows.Scan(&i.ModuleID, &i.ModuleTitle); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModuleByID = `-- name: GetModuleByID :one
SELECT
    m.id AS module_id,
    m.title AS module_title,
    m.user_id AS user_id,
    json_agg(json_build_object(
            'id', t.id,
            'title', t.title,
            'description', t.description
             )) AS terms
FROM
    modules m
        JOIN
    terms t ON m.id = t.module_id
WHERE
    m.id = $1
GROUP BY
    m.id, m.title
`

type GetModuleByIDRow struct {
	ModuleID    string
	ModuleTitle string
	UserID      string
	Terms       []byte
}

func (q *Queries) GetModuleByID(ctx context.Context, id string) (GetModuleByIDRow, error) {
	row := q.db.QueryRow(ctx, getModuleByID, id)
	var i GetModuleByIDRow
	err := row.Scan(
		&i.ModuleID,
		&i.ModuleTitle,
		&i.UserID,
		&i.Terms,
	)
	return i, err
}

const updateModule = `-- name: UpdateModule :exec
UPDATE modules SET title = $2 WHERE id = $1
`

type UpdateModuleParams struct {
	ID    string
	Title string
}

func (q *Queries) UpdateModule(ctx context.Context, arg UpdateModuleParams) error {
	_, err := q.db.Exec(ctx, updateModule, arg.ID, arg.Title)
	return err
}
