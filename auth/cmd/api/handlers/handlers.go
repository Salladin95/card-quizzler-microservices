package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/Salladin95/card-quizzler-microservices/auth-service/cmd/api/constants"
	user "github.com/Salladin95/card-quizzler-microservices/auth-service/cmd/api/user/entities"
	repo "github.com/Salladin95/card-quizzler-microservices/auth-service/cmd/api/user/repository"
	auth "github.com/Salladin95/card-quizzler-microservices/auth-service/proto"
	"log"
	"net/http"
)

// AuthServer is the gRPC server implementation for authentication-related operations.
type AuthServer struct {
	auth.UnimplementedAuthServer                 // Embed the autogenerated UnimplementedAuthServer to satisfy the interface.
	Repo                         repo.Repository // User repository
}

// SignIn handles the gRPC request for user sign-in.
func (authServer *AuthServer) SignIn(ctx context.Context, req *auth.SignInRequest) (*auth.Response, error) {
	fmt.Println("******* auth service - start processing signin request ********")
	// Extract payload from the gRPC request.
	reqPayload := req.GetPayload()
	// Create a SignInDto from the request payload.
	signInDto := user.SignInDto{Email: reqPayload.Email, Password: reqPayload.Password}
	// Verify the SignInDto structure.
	err := signInDto.Verify()
	if err != nil {
		return &auth.Response{Code: getErrorStatus(err), Message: getErrorMessage(err)}, nil
	}
	fetchedUser, err := authServer.Repo.GetByEmail(ctx, signInDto.Email)
	if err != nil {
		return &auth.Response{Code: getErrorStatus(err), Message: getErrorMessage(err)}, nil
	}
	isPasswordInvalid := authServer.Repo.CompareHashAndPassword(fetchedUser.Password, signInDto.Password)
	if fetchedUser.Email != signInDto.Email || isPasswordInvalid != nil {
		return &auth.Response{Code: getErrorStatus(err), Message: getErrorMessage(err)}, nil
	}
	return buildUserResponse(fetchedUser, http.StatusOK, "user has signed in")
}

// SignUp handles the gRPC request for user sign-up.
func (authServer *AuthServer) SignUp(ctx context.Context, req *auth.SignUpRequest) (*auth.Response, error) {
	fmt.Println("******* auth service - start processing signUp request ********")
	// Extract payload from the gRPC request.
	reqPayload := req.GetPayload()
	// Create a SignUpDto from the request payload.
	signUpDto := user.SignUpDto{Email: reqPayload.Email, Password: reqPayload.Password, Name: reqPayload.Name, Birthday: reqPayload.Birthday}
	// Verify the SignUpDto structure.
	err := signUpDto.Verify()
	if err != nil {
		return &auth.Response{Code: getErrorStatus(err), Message: getErrorMessage(err)}, nil
	}
	newUser, err := authServer.Repo.CreateUser(ctx, signUpDto)
	if err != nil {
		return &auth.Response{Code: getErrorStatus(err), Message: getErrorMessage(err)}, nil
	}
	return buildUserResponse(newUser, http.StatusCreated, "user has signed up")
}

func HandleRabbitPayload(key string, payload []byte) {
	fmt.Print("START PROCESSING MESSAGE")
	switch key {
	case constants.SignInKey:
		fmt.Printf("******* - %v\n\n", payload)
		var signInDto user.SignInDto
		err := json.Unmarshal(payload, &signInDto)
		if err != nil {
			log.Panic(err)
		}
		fmt.Println("******************* SIGN IN *****************")
		fmt.Printf("MESSAGE FROM QUEUE - %s\n", key)
		fmt.Printf("payload - %v\n\n", signInDto)
	case constants.SignUpKey:
		var signUpDto user.SignUpDto
		err := json.Unmarshal(payload, &signUpDto)
		if err != nil {
			log.Panic(err)
		}
		fmt.Println("******************* SIGN UP *****************")
		fmt.Printf("MESSAGE FROM QUEUE - %v", key)
	default:
		log.Panic("handlePayload: unknown payload name")
	}
}
