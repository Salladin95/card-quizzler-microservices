package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/Salladin95/card-quizzler-microservices/auth-service/cmd/api/constants"
	user "github.com/Salladin95/card-quizzler-microservices/auth-service/cmd/api/user/entities"
	repo "github.com/Salladin95/card-quizzler-microservices/auth-service/cmd/api/user/repository"
	auth "github.com/Salladin95/card-quizzler-microservices/auth-service/proto"
	"github.com/Salladin95/goErrorHandler"
	"log"
)

// AuthServer is the gRPC server implementation for authentication-related operations.
type AuthServer struct {
	auth.UnimplementedAuthServer                 // Embed the autogenerated UnimplementedAuthServer to satisfy the interface.
	Repo                         repo.Repository // User repository
}

// SignIn handles the gRPC request for user sign-in.
func (authServer *AuthServer) SignIn(ctx context.Context, req *auth.SignInRequest) (*auth.SignInResponse, error) {
	// Extract payload from the gRPC request.
	reqPayload := req.GetPayload()

	// Create a SignInDto from the request payload.
	signInDto := user.SignInDto{Email: reqPayload.Email, Password: reqPayload.Password}

	// Verify the SignInDto structure.
	err := signInDto.Verify()
	if err != nil {
		return nil, err
	}

	u, err := authServer.Repo.GetByEmail(ctx, signInDto.Email)

	if err != nil {
		return nil, goErrorHandler.IncorrectLoginOrPassword()
	}

	err = authServer.Repo.CompareHashAndPassword(u.Password, signInDto.Password)

	if err != nil || u.Email != signInDto.Email {
		return nil, goErrorHandler.IncorrectLoginOrPassword()
	}

	// Create and return a gRPC response message.
	res := &auth.SignInResponse{Message: fmt.Sprint("successfully signed in")}
	return res, nil
}

// SignUp handles the gRPC request for user sign-up.
func (authServer *AuthServer) SignUp(ctx context.Context, req *auth.SignUpRequest) (*auth.SignUpResponse, error) {
	// Extract payload from the gRPC request.
	reqPayload := req.GetPayload()

	// Create a SignUpDto from the request payload.
	signUpDto := user.SignUpDto{Email: reqPayload.Email, Password: reqPayload.Password, Name: reqPayload.Name, Birthday: reqPayload.Birthday}

	// Verify the SignUpDto structure.
	err := signUpDto.Verify()
	if err != nil {
		return nil, err
	}

	err = authServer.Repo.CreateUser(ctx, signUpDto)

	if err != nil {
		return nil, err
	}

	// Create and return a gRPC response message.
	res := &auth.SignUpResponse{Message: fmt.Sprint("new user is created")}
	return res, nil
}

func HandleRabbitPayload(key string, payload []byte) {
	fmt.Print("START PROCESSING MESSAGE")
	switch key {
	case constants.SignInKey:
		fmt.Printf("******* - %v\n\n", payload)
		var signInDto user.SignInDto
		err := json.Unmarshal(payload, &signInDto)
		if err != nil {
			log.Panic(err)
		}
		fmt.Println("******************* SIGN IN *****************")
		fmt.Printf("MESSAGE FROM QUEUE - %s\n", key)
		fmt.Printf("payload - %v\n\n", signInDto)
	case constants.SignUpKey:
		var signUpDto user.SignUpDto
		err := json.Unmarshal(payload, &signUpDto)
		if err != nil {
			log.Panic(err)
		}
		fmt.Println("******************* SIGN UP *****************")
		fmt.Printf("MESSAGE FROM QUEUE - %v", key)
	default:
		log.Panic("handlePayload: unknown payload name")
	}
}
